<!DOCTYPE aesl-source>
<network>


<!--list of global events-->


<!--list of constants-->
<constant value="100" name="PHYSIOLOGY_TICK"/>
<constant value="50" name="HEAT_CONSUMPTION_RATE"/>
<constant value="50" name="ENERGY_CONSUMPTION_RATE"/>
<constant value="420" name="FOOD_THRESHOLD_UPPER"/>
<constant value="320" name="FOOD_THRESHOLD_LOWER"/>
<constant value="610" name="HEAT_THRESHOLD_LOWER"/>
<constant value="750" name="HEAT_THRESHOLD_UPPER"/>
<constant value="200" name="ENERGY_INTAKE_PER_SE"/>
<constant value="200" name="TEMPERATURE_RISE_PER_SE"/>
<constant value="0" name="ENERGY_FATAL_LIMIT"/>
<constant value="9999" name="MAX_ENERGY"/>
<constant value="9999" name="MAX_TEMPERATURE"/>
<constant value="500" name="SPEED"/>
<constant value="0" name="TEMPERATURE_FATAL_LIMIT"/>
<constant value="1000" name="RANDOM_WALK_TICKS"/>
<constant value="0" name="MAX_VIEW"/>
<constant value="3000" name="PERSONAL_SPACE"/>
<constant value="5000" name="ENGERGY_DANGER_LIMIT"/>


<!--show keywords state-->
<keywords flag="true"/>


<!--node thymio-II-->
<node nodeId="1" name="thymio-II"># Overall metric
var survival_time
var overall_wellbeing
var physiological_balance

# Define and initialise variables
var energy # physiological variable
var temper # physiological variable
var alive # 0 = dead, other values = alive
var state = 0
var i

# Motivation variables
var energy_deficit = 0
var temperature_deficit = 0
var motivation_hunger
var motivation_cold
var stimulus_food = 0
var stimulus_heat = 0

# Behaviorur dependent variables
var selected_behaviour

# Actuator variables
var max_sval # maximum sensor value
var max_sval_i # index of maximum sensor val

# Initialize
callsub initialise_physiology
callsub reset_leds
callsub reset_motors

sub initialise_physiology
	energy = MAX_ENERGY # initial value for robot's energy
	temper = MAX_TEMPERATURE
	alive = 1 # robot is alive
	timer.period[0] = PHYSIOLOGY_TICK # millisecond timer

sub reset_leds
	call leds.top(0,0,0) # no light		

sub reset_motors
	motor.left.target = 0
	motor.right.target = 0

# Timer0 controls physiology update
onevent timer0
	if alive!=0 then
		callsub energy_decay
		callsub heat_loss
	end
	
# Energy variable goes down slowly over time if the robot does not eat
sub energy_decay
	energy -= ENERGY_CONSUMPTION_RATE/(1000/PHYSIOLOGY_TICK)
	if energy &lt; 0 then
		energy = 0
	end
	if energy &lt;= ENERGY_FATAL_LIMIT then
		callsub death
	end

# Temperature variable goes down slowly over time if the robot does not find heat
sub heat_loss
	temper -= HEAT_CONSUMPTION_RATE/(1000/PHYSIOLOGY_TICK)
	if temper &lt; 0 then
		temper = 0
	end
	if temper &lt;= TEMPERATURE_FATAL_LIMIT then
		callsub death
	end
		
sub death
	alive = 0
	call leds.top(32,0,0) # red = dead
	timer.period[0] = 0 # stop timer
	callsub reset_motors
	
# Proximity sensor events control behavior selection
onevent prox
	max_sval = prox.horizontal[0]
	max_sval_i = 0

	# Loop through the remaining front proximity sensors (1 to 4)
	for i in 1:4 do
		if prox.horizontal[i] > max_sval then
			max_sval = prox.horizontal[i] # record new max val
			max_sval_i = i # record index of new max val
		end
	end
	
	if alive!=0 then
		callsub ACTION_SELECTION
	end

sub ACTION_SELECTION
	# Robot behaviour controller goes here
	# Motivation architecture

	energy_deficit = MAX_ENERGY - energy
	temperature_deficit = MAX_TEMPERATURE - temper
	
	# Motivation = deficit + (deficit . stimulus)
	motivation_hunger = energy_deficit + (energy_deficit * stimulus_food)
	motivation_cold = temperature_deficit + (temperature_deficit * stimulus_heat )
	
	callsub reset_motors
	callsub reset_leds
	
	# Default behaviour
	#callsub behaviour_explore
	
	callsub behaviour_forward	
	
	if max_sval >= PERSONAL_SPACE then
		callsub behaviour_avoid
	end
			
	if motivation_hunger > ENGERGY_DANGER_LIMIT and prox.ground.delta[0] > FOOD_THRESHOLD_LOWER and prox.ground.delta[0] &lt; FOOD_THRESHOLD_UPPER or prox.ground.delta[1] > FOOD_THRESHOLD_LOWER and prox.ground.delta[1] &lt; FOOD_THRESHOLD_UPPER then
		callsub behaviour_go_to_food	
	else
		# callsub behaviour_go_to_heat	
	end
	
	
	#callsub behaviour_avoid
	#callsub behaviour_go_to_food
	#callsub behaviour_go_to_heat
	
	#callsub behaviour_retreat

#
# Individual behaviours
#
# AVOID-OBSTACLE		motor.right.target = mot_r
    # Braitenberg obstacle avoidance
sub behaviour_avoid
    if speed >0 then
        call math.dot(temp_braitenberg, prox.horizontal[0:4],
            weights_braitenberg, 4)
        call math.dot(temp_braitenberg_turn, prox.horizontal[0:4],
            weights_braitenberg_turn, 4)
        call math.muldiv(temp_braitenberg_left, speed,
            temp_braitenberg + temp_braitenberg_turn, 125)
        call math.muldiv(temp_braitenberg_right, speed,
            temp_braitenberg - temp_braitenberg_turn, 125)
        motor.left.target = speed - temp_braitenberg_left
        motor.right.target = speed - temp_braitenberg_right
    elseif speed &lt; 0 then
        temp_braitenberg = -300 / speed
        motor.left.target = speed + prox.horizontal[6] / temp_braitenberg
        motor.right.target = speed + prox.horizontal[5] / temp_braitenberg
    end
    # Saturation of left and right speed
    call math.min(motor.left.target, motor.left.target, vmax)
    call math.max(motor.left.target, motor.left.target, vmin)
    call math.min(motor.right.target, motor.right.target, vmax)
    call math.max(motor.right.target, motor.right.target, vmin)
 
    # Table border detection
    if prox.ground.reflected[0] &lt; 130 or prox.ground.reflected[1] &lt; 130 then 
        motor.left.target = 0
        motor.right.target = 0
        call leds.bottom.left(32, 0, 0)
        call leds.bottom.right(32, 0, 0)
    else
        call leds.bottom.left(0, 0, 0)
        call leds.bottom.right(0, 0, 0)
    end
	
# EXPLORE	
sub behaviour_explore
	callsub behaviour_forward
	#timer.period[1] = RANDOM_WALK_TICKS
return

# FIND FOOD		
sub behaviour_go_to_food
	call leds.top(0,32,0)
	if prox.ground.delta[0] > FOOD_THRESHOLD_LOWER and prox.ground.delta[0] &lt; FOOD_THRESHOLD_UPPER or prox.ground.delta[1] > FOOD_THRESHOLD_LOWER and prox.ground.delta[1] &lt; FOOD_THRESHOLD_UPPER then 
		callsub behaviour_eat	
	else
		callsub behaviour_explore	
	end	
	
# EAT	
sub behaviour_eat
	if prox.ground.delta[0] > FOOD_THRESHOLD_LOWER and prox.ground.delta[0] &lt; FOOD_THRESHOLD_UPPER or prox.ground.delta[1] > FOOD_THRESHOLD_LOWER and prox.ground.delta[1] &lt; FOOD_THRESHOLD_UPPER then
		call leds.top(0,32,0)
		callsub reset_motors
		energy += ENERGY_INTAKE_PER_SE # 10 because called at 10Hz
		if  energy > MAX_ENERGY then	
			energy = MAX_ENERGY
		end
	end

# FIND HEAT
sub behaviour_go_to_heat
	call leds.top(255,126,0)
	if prox.ground.delta[0] > HEAT_THRESHOLD_LOWER and prox.ground.delta[0] &lt; HEAT_THRESHOLD_UPPER or prox.ground.delta[1] > HEAT_THRESHOLD_LOWER and prox.ground.delta[1] &lt; HEAT_THRESHOLD_UPPER then
		callsub behaviour_warmup
	else
		callsub behaviour_explore	
	end



# WARMUP
sub behaviour_warmup
	if prox.ground.delta[0] > HEAT_THRESHOLD_LOWER and prox.ground.delta[0] &lt; HEAT_THRESHOLD_UPPER or prox.ground.delta[1] > HEAT_THRESHOLD_LOWER and prox.ground.delta[1] &lt; HEAT_THRESHOLD_UPPER then # food present
		call leds.top(255,126,0)
		callsub reset_motors
		temper += TEMPERATURE_RISE_PER_SE
		if  temper > MAX_TEMPERATURE then	
			temper = MAX_TEMPERATURE
		end
	end

# GO-TOWARDS-ENEMY
sub behaviour_go_towards_enemy

# FIGHT
sub behaviour_fight

# RUN-AWAY
sub behaviour_run_way

	

onevent timer1
	if alive > 0 then
		callsub behaviour_random_turn
	end

#
# Basic Actuators Behaviours
#
sub behaviour_forward
	motor.left.target += SPEED
	motor.right.target += SPEED
		
sub behaviour_turn_left
	motor.left.target = -SPEED
	motor.right.target = SPEED	
	
sub behaviour_turn_right
	motor.left.target = SPEED
	motor.right.target = -SPEED

sub behaviour_reverse
	motor.left.target = -SPEED
	motor.right.target = -SPEED

sub behaviour_random_turn	
	call math.rand(i)
	if  i > -1 then
		callsub behaviour_turn_right
	else
		callsub behaviour_turn_left	
	end
	

</node>


</network>
